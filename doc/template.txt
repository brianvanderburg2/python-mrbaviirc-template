Template Syntax
===============

A template consistes of one or more blocks.  There are currently four types
of blocks:

    TEXTBLOCK - This is a direct text block
    COMMENTBLOCK - This block is just for comments
    ACTIONBLOCK - This block can affect the template
    EMITTERBLOCK - This block emittes output from an expression.

Parsing is performed by searching for the first "{" character that starts a
tag in the template..  Everything before that becomes a TEXTBLOCK.  Then
parsing handles the tag as the correct type, and continues until the end of the
input.

General Syntax Definition
=========================

TEMPLATE: BLOCK*

BLOCK: (TEXTBLOCK | COMMENTBLOCK | ACTIONSEGMENT | EMITTERBLOCK)

WSNOTHING = ""
WSTRIMTONL = "-"
WSTRIMTONL_PRESERVENL = ("<" | "!" | "^")
WSADDNL = "+"

WS1CONTROL = (WSNOTHING | WSTRIMTONL | WSTRIMTONL_PRESERVENL | WSADDNL)
WS2CONTROL = (WSNOTHING | WSTRIMTONL | WSADDNL)

TEXTBLOCK: All text up to a starting tag "{"

COMMENTBLOCK: "{#" + WS1CONTROL + COMMENT + WS2CONTROL + "#}"
COMMENT: All text up to the terminating tag of the comment block

ACTIONBLOCK: "{%" + WS1CONTROL + ACTION + WS2CONTROL + "%}"
EMITTERBLOCK: "{{" + WS1CONTROL + EXPRESSION + WS2CONTROL + "}}"

ASSIGNMENT: VARPART + "=" + EXPRESSION
MULTIASSIGNMENT: ASSIGNMENT + ["," + ASSIGNMENT]*

ACTION:
    IF: "if" + EXPRESSION
    ELIF: "elif" + EXPRESSION
    ELSE: "else"
    ENDIF: "endif"
    FOR: "for" + VARPART + ["," + VARPART]? + "in" + EXPRESSION
    ENDFOR: "endfor"
    SWITCH: "switch" + EXPRESSION
    LT: "lt" + EXPRESSION
    LE: "le" + EXPRESSION
    GT: "gt" + EXPRESSION
    GE: "ge" + EXPRESSION
    NE: "ne" + EXPRESSION
    EQ: "eq" + EXPRESSION
    BT: "bt" + EXPRESSION + "," + EXPRESSION
    ENDSWITCH: "endswitch"
    SET: "set" + MULTIASSIGNMENT
    GLOBAL: "global" + MULTIASSIGNMENT
    TEMPLATE: "template" + MULTIASSIGNMENT
    SCOPE: "scope"
    ENDSCOPE: "endscope"
    INCLUDE: "include" + EXPRESSION + ["with" + MULTIASSIGNMENT]?
    RETURN: "return" + MULTIASSIGNMENT
    SECTION: "section" + EXPRESSION
    SECTION: "endsection"
    USE: "use" + EXPRESSION
    DEF: "def" +  STRING
    ENDDEF: "enddef"
    CALL: "call" + STRING
    VAR: "var" + VARPART
    ENDVAR: "endvar"
    CALLBACK: "callback" + VARPART + ["(" +MULTIEXPRESSION? + ")" ]?
    ERROR: "error" + EXPRESSION
    IMPORT: ("import" | "gimport") + MULTIASSIGNMENT
    AUTOSTRIP: "autostrip" | "autotrim" | "no_autostrip" |
        "push_autostrip" + ("on" | "off" | "trim") |
        "pop_autostrip"

MULTIEXPRESSION: EXPRESSION + ["," + EXPRESSION]*
EXPRESSION:
    STRING
    INTEGER
    FLOAT
    LIST
    VAR
    VARINDEX
    FUNC

LIST: "[" + MULTIEXPRESSION? + "]"
VAR: VARPART + ["." + VARPART]*
VARINDEX: VAR + "[" + MULTIEXPRESSION + "]"
VARPART: regex [A-Za-z_][A-Za-z0-9_]*
FUNC: VAR + "(" + MULTIEXPRESSION? + ")"

ACTIONSEGMENT:
    IFSEGMENT
    FORSEGMENT
    SWITCHSEGMENT
    ACTIONBLOCK(ACTION:SET)
    ACTIONBLOCK(ACTION:GLOBAL)
    SCOPESEGMENT
    ACTIONBLOCK(ACTION:INCLUDE)
    SECTIONSEGMENT
    ACTIONBLOCK(ACTION:USE)
    DEFSEGMENT
    ACTIONBLOCK(ACTION:CALL)
    VARSEGMENT
    ACTIONBLOCK(ACTION:CALLBACK)
    ACTIONBLOCK(ACTION:ERROR)
    ACTIONBLOCK(ACTION:IMPORT)
    ACTIONBLOCK(ACTION:AUTOSTRIP)

IFSEGMENT:
    ACTIONBLOCK(ACTION:IF) +
    BLOCK* +
    [
        ACTIONBLOCK(ACTION:ELIF) +
        BLOCK*
    ]* +
    [
        ACTIONBLOCK(ACTION:ELSE) +
        BLOCK*
    ]? +
    ACTIONBLOCK(ACTION:ENDIF)

FORSEGMENT:
    ACTIONBLOCK(ACTION:FOR) +
    BLOCK* +
    [
        ACTIONBLOCK(ACTION:ELSE) +
        BLOCK*
    ]? +
    ACTIONBLOCK(ACTION:ENDFOR)

SWITCHSEGMENT:
    ACTIONBLOCK(ACTION:SWITCH) +
    BLOCK* +
    [
        (ACTIONBLOCK(ACTION:LT) | ACTIONBLOCK(ACTION:LE) |
         ACTIONBLOCK(ACTION:GT) | ACTIONBLOCK(ACTION:GE) |
         ACTIONBLOCK(ACTION:NE) | ACTIONBLOCK(ACTION:EQ) |
         ACTIONBLOCK(ACTION:BT)) +
        BLOCK*
    ]* +
    ACTIONBLOCK(ACTION:ENDSWITCH]

SCOPESEGMENT:
    ACTIONBLOCK(ACTION:SCOPE) +
    BLOCK* +
    ACTIONBLOCK(ACTION:ENDSCOPE)

SECTIONSEGMENT:
    ACTIONBLOCK(ACTION:SECTION) +
    BLOCK* +
    ACTIONBLOCK(ACTION:ENDSECTION)

DEFSEGMENT:
    ACTIONBLOCK(ACTION:DEF) +
    BLOCK* +
    ACTIONBLOCK(ACTION:ENDDEF)

VARSEGMENT:
    ACTIONBLOCK(ACTION:VAR) +
    BLOCK* +
    ACTIONBLOCK(ACTION:ENDVAR)


Functions
=========

Template functions are provided by passing variables to the environment.  If
a variable is called as a function, then it will be attempted to use it as
a function and pass any arguments supported to it.

Some internal library functions are provided in the mrbavii.template.StdLib
class.  To pass these, just assign an instance of this class to a context
variable:

    env = Environment({"lib": StdLib()})


Library Functions
=================

str(value) - Return the string form of a value
int(value) - Return the interger form of a value
float(value) - Return the float form of a value

add(value1, value2) - Add two values: value1 + value2
sub(value2, value2) - Subtract two values: value1 - value2
mul(value1, value2) - Multiply two values: value1 * value2
div(value1, value2) - Divide two values: value1 / value2
mod(value1, value2) - Determine a remainder: value1 % value2

iseven(value) - Return true if a value is even
isodd(value) - Return true if a value is odd
eq(value1, value2) - Return true if two values are equal
ne(value1, value2) - Return true if two values are not equal)

concat(value...) - Concatenate multiple strings together



Library Objects
===============



Planned Changes/Ideas
=====================

Importable functions
====================

Status: Idea

Register function libraries with more meaningful names. Allows template author
to import to a specific variable if needed:


fn()
    return lib

env.register("unique-name", fn)
env.register("another-nane", fn2)


{% import lib1 "unique-name" %}

{% set data = lib1.getdata(...) %}
 
Standard functions at top level
===============================

Status: Idea

comparision:
    lt(x, y)  x < y
    le(x, y)  x <= y
    gt(x, y)  x > y
    ge(x, y)  x >= y
    eq(x, y)  x == y
    ne(x, y)  x != y
    bt(x, y, z)  x >= y && x <= z

operators
    add(x, y)  x + y
    sub(x, y)  x - y
    mul(x, y)  x * y
    div(x, y)  x / y
    mod(x, y)  x % y
    neg(x)     -x
    inv(x)     ~x

logic
    not(x)     !x
    and(x, y)  x and y
    or(x, y)   x or y
    xor(x, y)  x xor y

conversion
    str(x)
    int(x)
    float(x)
    bool(x)
